use std::collections::{HashMap, HashSet};
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use syn::{
    visit::{self, Visit}, ItemFn, Visibility, ExprUnsafe, ImplItemFn, UseTree, 
};
use quote::ToTokens;
use std::time::{Duration, Instant};

// 表示函数的基本信息
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct FunctionInfo {
    name: String,
    module_path: String,
    visibility: VisibilityKind,
    has_internal_unsafe: bool,
    file_path: String, // 添加文件路径信息
}

// 表示函数的可见性
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum VisibilityKind {
    Public,       // pub fn
    Crate,        // pub(crate) fn
    Module,       // fn (私有)
    Restricted,   // pub(in path) fn 或 pub(super) fn
}

// 函数调用关系
#[derive(Debug)]
struct FunctionCall {
    caller: String,    // 调用者的完整路径
    callee: String,    // 被调用者的完整路径
}

// 函数调用图
struct CallGraph {
    // 从函数完整路径到函数信息的映射
    functions: HashMap<String, FunctionInfo>,
    // 从调用者到被调用者的映射
    calls: HashMap<String, HashSet<String>>,
    // 从被调用者到调用者的映射（反向图）
    reverse_calls: HashMap<String, HashSet<String>>,
    // 包含内部不安全代码的函数
    unsafe_functions: HashSet<String>,
    // 公开函数
    public_functions: HashSet<String>,
    // 公开且不安全的函数
    public_unsafe_functions: HashSet<String>,
    // 保存每个文件的分析结果
    file_results: HashMap<String, Vec<Vec<String>>>,
}

impl CallGraph {
    fn new() -> Self {
        CallGraph {
            functions: HashMap::new(),
            calls: HashMap::new(),
            reverse_calls: HashMap::new(),
            unsafe_functions: HashSet::new(),
            public_functions: HashSet::new(),
            public_unsafe_functions: HashSet::new(),
            file_results: HashMap::new(),
        }
    }

    // 添加函数到图中
    fn add_function(&mut self, path: String, info: FunctionInfo) {
        if info.visibility == VisibilityKind::Public {
            self.public_functions.insert(path.clone());
            
            // 如果函数既是公开的又包含不安全代码，添加到新集合中
            if info.has_internal_unsafe {
                self.public_unsafe_functions.insert(path.clone());
            }
        }
        
        if info.has_internal_unsafe {
            self.unsafe_functions.insert(path.clone());
        }
        
        self.functions.insert(path, info);
    }

    // 添加函数调用关系
    fn add_call(&mut self, caller: String, callee: String) {
        self.calls.entry(caller.clone()).or_insert_with(HashSet::new).insert(callee.clone());
        self.reverse_calls.entry(callee).or_insert_with(HashSet::new).insert(caller);
    }

    // 重置调用图，用于分析新文件
    fn reset(&mut self) {
        self.functions.clear();
        self.calls.clear();
        self.reverse_calls.clear();
        self.unsafe_functions.clear();
        self.public_functions.clear();
        self.public_unsafe_functions.clear();
    }

    // 查找从公开函数到内部不安全函数的所有有效路径，针对单个文件
    fn find_paths_to_unsafe(&self) -> Vec<Vec<String>> {
        let mut all_paths = Vec::new();
        
        // 首先添加所有直接公开的不安全函数
        for pub_unsafe_fn in &self.public_unsafe_functions {
            let mut path = Vec::new();
            path.push(pub_unsafe_fn.clone());
            all_paths.push(path);
        }
        
        // 获取非公开的不安全函数
        let non_public_unsafe = self.unsafe_functions.difference(&self.public_unsafe_functions)
                                                   .cloned()
                                                   .collect::<HashSet<String>>();
        
        // 对每个公开函数，查找到非公开不安全函数的路径
        for pub_fn in &self.public_functions {
            // 排除已经是公开不安全的函数
            if !self.public_unsafe_functions.contains(pub_fn) {
                let paths = self.find_valid_paths(pub_fn, &non_public_unsafe);
                all_paths.extend(paths);
            }
        }
        
        all_paths
    }

    // 查找从起始函数到目标函数集合中任意一个函数的所有有效路径
    // 有效路径指的是中间节点不包含unsafe函数或公开的不安全函数
    fn find_valid_paths(&self, start: &String, targets: &HashSet<String>) -> Vec<Vec<String>> {
        let mut all_paths = Vec::new();
        let mut visited = HashSet::new();
        let mut path = Vec::new();
        
        self.dfs_find_valid_paths(start, targets, &mut visited, &mut path, &mut all_paths);
        
        all_paths
    }

    // 深度优先搜索查找有效路径
    fn dfs_find_valid_paths(
        &self,
        current: &String,
        targets: &HashSet<String>,
        visited: &mut HashSet<String>,
        path: &mut Vec<String>,
        all_paths: &mut Vec<Vec<String>>,
    ) {
        if visited.contains(current) {
            return; // 避免循环
        }
        
        // 检查当前节点是否是中间节点，如果是则检查是否为unsafe函数或公开的不安全函数
        if !path.is_empty() && !targets.contains(current) {
            // 跳过中间节点为unsafe函数或公开的不安全函数的路径
            if self.unsafe_functions.contains(current) || self.public_unsafe_functions.contains(current) {
                return;
            }
        }
        
        visited.insert(current.clone());
        path.push(current.clone());
        
        if targets.contains(current) {
            all_paths.push(path.clone()); // 找到一条有效路径
        } else if let Some(callees) = self.calls.get(current) {
            for callee in callees {
                self.dfs_find_valid_paths(callee, targets, visited, path, all_paths);
            }
        }
        
        // 回溯
        path.pop();
        visited.remove(current);
    }
    
    // 将当前文件的结果保存到文件结果集中
    fn save_file_results(&mut self, file_path: &str) {
        let paths = self.find_paths_to_unsafe();
        self.file_results.insert(file_path.to_string(), paths);
    }
}

// 用于收集函数信息和检测unsafe块的访问者
struct FunctionVisitor {
    current_module_path: Vec<String>,
    functions: HashMap<String, FunctionInfo>,
    unsafe_functions: HashSet<String>,
    current_function: Option<String>,
    has_unsafe: bool,
    file_path: String, // 添加文件路径
}

impl FunctionVisitor {
    fn new(file_path: String) -> Self {
        FunctionVisitor {
            current_module_path: Vec::new(),
            functions: HashMap::new(),
            unsafe_functions: HashSet::new(),
            current_function: None,
            has_unsafe: false,
            file_path, // 保存文件路径
        }
    }
    
    // 获取当前模块路径
    fn get_current_module_path(&self) -> String {
        self.current_module_path.join("::")
    }
    
    // 从syn::Visibility转换为VisibilityKind
    fn convert_visibility(&self, vis: &Visibility) -> VisibilityKind {
        match vis {
            Visibility::Public(_) => VisibilityKind::Public,
            Visibility::Restricted(restricted) if restricted.path.is_ident("crate") => VisibilityKind::Crate,
            Visibility::Restricted(_) => VisibilityKind::Restricted,
            _ => VisibilityKind::Module,
        }
    }
    
    // 将函数添加到结果集
    fn add_function(&mut self, name: String, vis: &Visibility) {
        let module_path = self.get_current_module_path();
        let full_path = if module_path.is_empty() {
            name.clone()
        } else {
            format!("{}::{}", module_path, name)
        };
        
        self.current_function = Some(full_path.clone());
        self.has_unsafe = false;
        
        let info = FunctionInfo {
            name,
            module_path,
            visibility: self.convert_visibility(vis),
            has_internal_unsafe: false, // 稍后更新
            file_path: self.file_path.clone(), // 添加文件路径信息
        };
        
        self.functions.insert(full_path, info);
    }
    
    // 更新当前函数的unsafe状态
    fn update_unsafe_state(&mut self) {
        if let Some(ref func_path) = self.current_function {
            if self.has_unsafe {
                if let Some(info) = self.functions.get_mut(func_path) {
                    info.has_internal_unsafe = true;
                    self.unsafe_functions.insert(func_path.clone());
                }
            }
        }
    }
}

impl<'ast> Visit<'ast> for FunctionVisitor {
    // 访问模块
    fn visit_item_mod(&mut self, i: &'ast syn::ItemMod) {
        self.current_module_path.push(i.ident.to_string());
        
        // 访问模块内容
        if let Some((_, items)) = &i.content {
            for item in items {
                visit::visit_item(self, item);
            }
        }
        
        self.current_module_path.pop();
    }
    
    // 访问函数定义
    fn visit_item_fn(&mut self, i: &'ast ItemFn) {
        let name = i.sig.ident.to_string();
        self.add_function(name, &i.vis);
        
        // 访问函数体
        visit::visit_block(self, &i.block);
        
        // 更新unsafe状态
        self.update_unsafe_state();
        self.current_function = None;
    }
    
    // 访问impl块中的函数
    fn visit_impl_item_fn(&mut self, i: &'ast ImplItemFn) {
        let name = i.sig.ident.to_string();
        self.add_function(name, &i.vis);
        
        // 访问函数体
        visit::visit_block(self, &i.block);
        
        // 更新unsafe状态
        self.update_unsafe_state();
        self.current_function = None;
    }
    
    // 访问unsafe块
    fn visit_expr_unsafe(&mut self, i: &'ast ExprUnsafe) {
        self.has_unsafe = true;
        
        // 继续访问unsafe块内部
        visit::visit_expr_unsafe(self, i);
    }
}

// 用于收集函数调用关系的访问者
struct CallVisitor {
    current_module_path: Vec<String>,
    current_function: Option<String>,
    calls: Vec<FunctionCall>,
    // 导入的模块和别名映射
    imports: HashMap<String, String>,
}

impl CallVisitor {
    fn new() -> Self {
        CallVisitor {
            current_module_path: Vec::new(),
            current_function: None,
            calls: Vec::new(),
            imports: HashMap::new(),
        }
    }
    
    // 获取当前模块路径
    fn get_current_module_path(&self) -> String {
        self.current_module_path.join("::")
    }
    
    // 处理函数调用表达式
    fn handle_call(&mut self, func_path: &syn::Path) {
        if let Some(ref caller) = self.current_function {
            let callee = self.resolve_path(func_path);
            self.calls.push(FunctionCall {
                caller: caller.clone(),
                callee,
            });
        }
    }
    
    // 解析路径，处理导入和别名
    fn resolve_path(&self, path: &syn::Path) -> String {
        let path_str = path.to_token_stream().to_string().replace(' ', "");
        
        // 检查是否是导入的模块或别名
        if path.segments.len() > 0 {
            let first_segment = &path.segments[0].ident.to_string();
            if let Some(import) = self.imports.get(first_segment) {
                // 替换路径的第一部分为导入的完整路径
                return path_str.replacen(first_segment, import, 1);
            }
        }
        
        // 如果是相对路径（不以crate::或::开头），加上当前模块路径
        if !path_str.starts_with("crate::") && !path_str.starts_with("::") {
            let module_path = self.get_current_module_path();
            if !module_path.is_empty() {
                return format!("{}::{}", module_path, path_str);
            }
        }
        
        path_str
    }
    
    // 处理导入语句
    fn process_use(&mut self, use_tree: &UseTree, prefix: &str) {
        match use_tree {
            UseTree::Path(use_path) => {
                let next_prefix = if prefix.is_empty() {
                    use_path.ident.to_string()
                } else {
                    format!("{}::{}", prefix, use_path.ident)
                };
                self.process_use(&*use_path.tree, &next_prefix);
            },
            UseTree::Name(use_name) => {
                let full_path = if prefix.is_empty() {
                    use_name.ident.to_string()
                } else {
                    format!("{}::{}", prefix, use_name.ident)
                };
                // 添加到导入映射
                self.imports.insert(use_name.ident.to_string(), full_path);
            },
            UseTree::Rename(use_rename) => {
                let full_path = if prefix.is_empty() {
                    use_rename.ident.to_string()
                } else {
                    format!("{}::{}", prefix, use_rename.ident)
                };
                // 添加别名到导入映射
                self.imports.insert(use_rename.rename.to_string(), full_path);
            },
            UseTree::Glob(_) => {
                // 处理通配符导入较复杂，这里简化处理
            },
            UseTree::Group(use_group) => {
                for tree in &use_group.items {
                    self.process_use(tree, prefix);
                }
            },
        }
    }
}

impl<'ast> Visit<'ast> for CallVisitor {
    // 访问模块
    fn visit_item_mod(&mut self, i: &'ast syn::ItemMod) {
        self.current_module_path.push(i.ident.to_string());
        
        // 访问模块内容
        if let Some((_, items)) = &i.content {
            for item in items {
                visit::visit_item(self, item);
            }
        }
        
        self.current_module_path.pop();
    }
    
    // 访问函数定义
    fn visit_item_fn(&mut self, i: &'ast ItemFn) {
        let name = i.sig.ident.to_string();
        let module_path = self.get_current_module_path();
        let full_path = if module_path.is_empty() {
            name
        } else {
            format!("{}::{}", module_path, name)
        };
        
        self.current_function = Some(full_path);
        
        // 访问函数体
        visit::visit_block(self, &i.block);
        
        self.current_function = None;
    }
    
    // 访问impl块中的函数
    fn visit_impl_item_fn(&mut self, i: &'ast ImplItemFn) {
        let name = i.sig.ident.to_string();
        let module_path = self.get_current_module_path();
        let full_path = if module_path.is_empty() {
            name
        } else {
            format!("{}::{}", module_path, name)
        };
        
        self.current_function = Some(full_path);
        
        // 访问函数体
        visit::visit_block(self, &i.block);
        
        self.current_function = None;
    }
    
    // 访问函数调用表达式
    fn visit_expr_call(&mut self, i: &'ast syn::ExprCall) {
        // 检查被调用的表达式是否是路径（函数名）
        if let syn::Expr::Path(expr_path) = &*i.func {
            self.handle_call(&expr_path.path);
        }
        
        // 继续访问参数
        for arg in &i.args {
            visit::visit_expr(self, arg);
        }
    }
    
    // 访问方法调用表达式
    fn visit_expr_method_call(&mut self, i: &'ast syn::ExprMethodCall) {
        // 方法调用更复杂，需要类型信息才能准确解析
        // 这里简化处理，只记录方法名
        if let Some(ref caller) = self.current_function {
            let method_name = i.method.to_string();
            // 简化：假设方法是在当前模块中定义的
            let module_path = self.get_current_module_path();
            let callee = if module_path.is_empty() {
                method_name
            } else {
                format!("{}::{}", module_path, method_name)
            };
            
            self.calls.push(FunctionCall {
                caller: caller.clone(),
                callee,
            });
        }
        
        // 继续访问接收者和参数
        visit::visit_expr(self, &i.receiver);
        for arg in &i.args {
            visit::visit_expr(self, arg);
        }
    }
    
    // 访问导入语句
    fn visit_item_use(&mut self, i: &'ast syn::ItemUse) {
        self.process_use(&i.tree, "");
        visit::visit_item_use(self, i);
    }
}

// 静态分析器
struct StaticAnalyzer {
    call_graph: CallGraph,
    file: Option<File>,
}

impl StaticAnalyzer {
    fn new() -> Self {
        StaticAnalyzer {
            call_graph: CallGraph::new(),
            file: None,
        }
    }

    // 添加初始化输出文件的方法
    fn init_output_file(&mut self, output_path: &Path) -> io::Result<()> {
        self.file = Some(File::create(output_path)?);
        Ok(())
    }

    // 修改分析文件的方法，添加文件大小限制和超时处理
    fn analyze_file(&mut self, file_path: &Path) -> io::Result<()> {
        // 检查文件大小
        let metadata = fs::metadata(file_path)?;
        if metadata.len() > 10 * 1024 * 1024 { // 10MB 限制
            eprintln!("Skipping large file {}: {} MB", file_path.display(), metadata.len() / 1024 / 1024);
            return Ok(());
        }

        let start_time = Instant::now();
        let timeout = Duration::from_secs(30); // 30秒超时
        
        let source = match fs::read_to_string(file_path) {
            Ok(content) => content,
            Err(e) => {
                eprintln!("Error reading file {}: {}", file_path.display(), e);
                return Ok(()); // 改为 Ok 以继续处理其他文件
            }
        };
        
        // 解析源代码
        let syntax = match syn::parse_file(&source) {
            Ok(parsed) => parsed,
            Err(e) => {
                eprintln!("Error parsing file {}: {}", file_path.display(), e);
                return Ok(()); // 改为 Ok 以继续处理其他文件
            }
        };
        
        // 在分析新文件前重置调用图
        self.call_graph.reset();
        
        // 收集函数信息，检查超时
        let file_path_str = file_path.to_string_lossy().to_string();
        let mut fn_visitor = FunctionVisitor::new(file_path_str.clone());
        fn_visitor.visit_file(&syntax);
        
        if start_time.elapsed() > timeout {
            eprintln!("Analysis timeout for file: {}", file_path.display());
            return Ok(());
        }

        // 收集函数调用关系
        let mut call_visitor = CallVisitor::new();
        call_visitor.visit_file(&syntax);
        
        if start_time.elapsed() > timeout {
            eprintln!("Analysis timeout for file: {}", file_path.display());
            return Ok(());
        }

        // 将结果添加到调用图
        for (path, info) in fn_visitor.functions {
            self.call_graph.add_function(path, info);
        }
        
        for call in call_visitor.calls {
            self.call_graph.add_call(call.caller, call.callee);
        }
        
        // 获取分析结果并立即写入文件
        let paths = self.call_graph.find_paths_to_unsafe();
        
        // 过滤出长度大于1的路径
        let valid_paths: Vec<_> = paths.iter()
            .filter(|path| path.len() > 1)
            .collect();

        if !valid_paths.is_empty() {
            if let Some(file) = &mut self.file {
                // 写入文件信息
                writeln!(file, "File: {}", file_path.display())?;
                writeln!(file, "Found {} valid paths from public functions to internal unsafe functions:", valid_paths.len())?;
                
                // 写入每条路径
                for (i, path) in valid_paths.iter().enumerate() {
                    writeln!(file, "{}. {}", i + 1, Self::format_path(path, &self.call_graph.functions))?;
                }
                
                // 写入分隔符
                writeln!(file, "{}", "=".repeat(80))?;
            }
        }

        Ok(())
    }

    // 修改目录分析方法，添加进度显示
    fn analyze_directory(&mut self, dir_path: &Path) -> io::Result<()> {
        let start_time = Instant::now();
        let mut files_processed = 0;
        
        let walk_dir = walkdir::WalkDir::new(dir_path)
            .follow_links(false)
            .into_iter()
            .filter_map(|e| e.ok());

        for entry in walk_dir {
            let path = entry.path();
            
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Err(e) = self.analyze_file(path) {
                    eprintln!("Error analyzing file {}: {}", path.display(), e);
                }
                
                files_processed += 1;
                if files_processed % 100 == 0 {
                    println!("Processed {} files in {:?}", files_processed, start_time.elapsed());
                }
            }
        }

        println!("Total files processed: {} in {:?}", files_processed, start_time.elapsed());
        Ok(())
    }
    
    fn write_results_to_file(&self, output_path: &Path) -> io::Result<()> {
        println!("Writing results to: {}", output_path.display());
        
        let mut file = File::create(output_path)?;
        
        for (file_path, paths) in &self.call_graph.file_results {
            // 过滤出长度大于1的路径
            let valid_paths: Vec<_> = paths.iter()
                .filter(|path| path.len() > 1)
                .collect();

            if !valid_paths.is_empty() {
                // 文件标题
                writeln!(file, "File: {}", file_path)?;
                writeln!(file, "Found {} valid paths from public functions to internal unsafe functions:", valid_paths.len())?;
                
                // 输出每条路径
                for (i, path) in valid_paths.iter().enumerate() {
                    writeln!(file, "{}. {}", i + 1, Self::format_path(path, &self.call_graph.functions))?;
                }
                
                // 分隔符
                writeln!(file, "{}", "=".repeat(80))?;
            }
        }
        
        Ok(())
    }
    
    // 修改格式化路径方法，只输出函数名
    fn format_path(path: &[String], _functions: &HashMap<String, FunctionInfo>) -> String {
        path.iter()
            .enumerate()
            .map(|(i, func_name)| {
                // 获取函数名的最后一个部分（去掉模块路径）
                let simple_name = func_name.split("::").last().unwrap_or(func_name);
                if i == 0 {
                    simple_name.to_string()
                } else {
                    format!(" -> {}", simple_name)
                }
            })
            .collect::<String>()
    }
}

// 修改 main 函数
fn main() -> io::Result<()> {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <path-to-rust-project-or-file> [output-file]", args[0]);
        eprintln!("  <path-to-rust-project-or-file>: Path to a Rust file or directory");
        eprintln!("  [output-file]: Optional path to save results (default: unsafe_paths.txt)");
        return Ok(());
    }

    let input_path = PathBuf::from(&args[1]);
    let output_path = if args.len() >= 3 {
        PathBuf::from(&args[2])
    } else {
        PathBuf::from("unsafe_paths.txt")
    };
    
    let mut analyzer = StaticAnalyzer::new();
    analyzer.init_output_file(&output_path)?;
    
    // 验证路径是否存在
    if !input_path.exists() {
        eprintln!("Error: Path does not exist: {}", input_path.display());
        return Ok(());
    }
    
    println!("Starting analysis of: {}", input_path.display());
    
    // 如果是目录，递归分析每个文件，否则分析单个文件
    if input_path.is_dir() {
        if let Err(e) = analyzer.analyze_directory(&input_path) {
            eprintln!("Error analyzing directory: {}", e);
        }
    } else if input_path.extension().map_or(false, |ext| ext == "rs") {
        if let Err(e) = analyzer.analyze_file(&input_path) {
            eprintln!("Error analyzing file: {}", e);
        }
    } else {
        eprintln!("The path must be a Rust file (.rs) or a directory containing Rust files: {}", 
                  input_path.display());
        return Ok(());
    }
    
    println!("Analysis complete! Results saved to: {}", output_path.display());
    
    Ok(())
}